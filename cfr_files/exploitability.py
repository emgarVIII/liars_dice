#!/usr/bin/env python3
import json
from stub import compute_utility_vector_pl1, uniform_sf_strategy

def load_policy(path):
    with open(path) as f:
        return json.load(f)

def build_strat1(policy):
    # turns {infoset: {action:prob}} into { (infoset,action):prob }
    return {
        (infoset, action): p
        for infoset, dist in policy.items()
        for action, p in dist.items()
    }

def exploitability(game_path, policy_path, call_p):
    game   = json.load(open(game_path))
    for entry in game["utility_pl1"]:
        entry["sequence_pl1"] = tuple(entry["sequence_pl1"])
        entry["sequence_pl2"] = tuple(entry["sequence_pl2"])

    policy = load_policy(policy_path)
    strat1 = build_strat1(policy)

    # build P2 strategy: uniform at all Infosets, then override call/accept
    strat2 = uniform_sf_strategy(game["decision_problem_pl2"])
    strat2[("d1_pl2","call")]   = call_p
    strat2[("d1_pl2","accept")] = 1 - call_p

    # compute the utility‐vector for P1 against this P2
    u = compute_utility_vector_pl1(game, strat2)

    # expected utility of P1 under strat1
    eu = sum(strat1[s] * u[s] for s in strat1)
    win_rate = (eu + 1) / 2
    return win_rate

if __name__=="__main__":
    GAME   = "games/liarsdice_5die_1bid.json"
    POLICY = "../policies/liarsdice_5die_policy.json"   # or wherever your JSON lives

    for call_pct in [100, 90, 80, 70, 60, 50]:
        p = call_pct / 100
        wr = exploitability(GAME, POLICY, p)
        print(f"P2 calls {call_pct:>3}%   →   P1 win rate ≈ {wr:.3f}")
